ALU:
	add, sub, mul, div,
	shl, shr, and, or,
	not, nor, xor, cmp,
Memory:
	mov, jmp, call, ret,
	push, pop, pusha, popa,
	popi, iret
Conditionals:
	jne, jc, jl, jle,
	jge, jo, je, rfl,				// Read flags
I/O:
	in, out, int, hlt,
	cli, sti

Microinstruction:
Bit 11: 64 or 32 bit (32 is 0)
Bit 10: ALU Instruction?
Bit 9: Op Count (value + 1)
Bit 8: R/W Op 1? (op 1 is always read AND write if set) (if set to 0 its assumed there are no ops)
Bit 7: R/W Op 2?
Bit 6: If ALU, logic or math (logic is 1). If not, internal or I/O (I/O is 0)
Bit 5: Read AND Write op2?
Bit 4: Immediate Value?
Bits 3-0: Offset in grouping

Memory instructions get an extra two bits for operands:
0b00: Op1 and Op2 are imm
0b01: Op1 is imm, Op2 is reg
0b10: Op1 is reg, Op2 is imm
0b11: Op1 and Op2 are reg
These would be bits 13-12;

Microcode:

fetch, add, sub, mul,
div, shl, shr, and,
or, not, nor, xor, cmp
set, load, store, I/O,
hlt